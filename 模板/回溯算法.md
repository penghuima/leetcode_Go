废话不多说，直接上回溯算法框架。**解决一个回溯问题，实际上就是一个决策树的遍历过程**。你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。(记录已经做出的选择)

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。

代码方面，回溯算法的框架：

```go
路径 path []int
选择列表 nums []int
标记是否选择 visited map[int]bool

func backtrack(选择列表) (result [][]int){
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        #做选择
        将该选择从选择列表中移除
        路径.add(选择)
        backtrack(选择列表)
        #撤销选择
        路径.remove(选择)
        将该选择恢复到选择列表
}
```

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**，特别简单。

> ==递归用来纵向遍历，for循环用来横向遍历==

**总结**   

> backTrack() 函数参数列表中带不带 index 参数

其实归根结底到底带不带 index , 看决策树的结构，如果是全决策树如全排列就不需要带，如果决策树是左胖右瘦的如子集这类就需要。但我自己想说的是其实在全排列这种决策树中也可以使用 index 只不过在单层搜索逻辑中的for循环要写成 `for i := 0; i < length; i++`，而在子集这类题中的单层搜索逻辑需要写成 `for i := index; i < length; i++` 。仔细品味，一个是i:=0 、一个是 i:=index ，前者是可以使用 index 下标之前的元素，但需要额外一个 used 切片来记录哪些元素已经使用过，从选择列表中排除掉。后者则不需要used切片了，通过使用index下标及以后的元素已经可以自动避免重复了

