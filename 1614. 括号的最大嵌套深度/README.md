#### [1614. 括号的最大嵌套深度](https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/)

> 难度简单

如果字符串满足以下条件之一，则可以称之为 **有效括号字符串**（valid parentheses string**，可以简写为 **VPS）：

- 字符串是一个空字符串 `""`，或者是一个不为 `"("` 或 `")"` 的单字符。
- 字符串可以写为 `AB`（`A` 与 `B` 字符串连接），其中 `A` 和 `B` 都是 **有效括号字符串** 。
- 字符串可以写为 `(A)`，其中 `A` 是一个 **有效括号字符串** 。

类似地，可以定义任何有效括号字符串 `S` 的 **嵌套深度** `depth(S)`：

- `depth("") = 0`
- `depth(C) = 0`，其中 `C` 是单个字符的字符串，且该字符不是 `"("` 或者 `")"`
- `depth(A + B) = max(depth(A), depth(B))`，其中 `A` 和 `B` 都是 **有效括号字符串**
- `depth("(" + A + ")") = 1 + depth(A)`，其中 `A` 是一个 **有效括号字符串**

例如：`""`、`"()()"`、`"()(()())"` 都是 **有效括号字符串**（嵌套深度分别为 0、1、2），而 `")("` 、`"(()"` 都不是 **有效括号字符串** 。

给你一个 **有效括号字符串** `s`，返回该字符串的 `s` **嵌套深度** 。

**示例 1：**

```
输入：s = "(1+(2*3)+((8)/4))+1"
输出：3
解释：数字 8 在嵌套的 3 层括号中。
```

**示例 2：**

```
输入：s = "(1)+((2))+(((3)))"
输出：3
```

**示例 3：**

```
输入：s = "1+(2*3)/(2-1)"
输出：1
```

**示例 4：**

```
输入：s = "1"
输出：0
```

**提示：**

- `1 <= s.length <= 100`
- `s` 由数字 `0-9` 和字符 `'+'`、`'-'`、`'*'`、`'/'`、`'('`、`')'` 组成
- 题目数据保证括号表达式 `s` 是 **有效的括号表达式**

#### 解题思路

对于括号计算类题目，我们往往可以用**栈**来思考。

遍历字符串 s，如果遇到了一个左括号，那么就将其入栈；如果遇到了一个右括号，那么就弹出栈顶的左括号，与该右括号匹配。这一过程中的栈的大小的最大值，即为 s 的嵌套深度。

代码实现时，由于我们只需要考虑栈的大小，我们可以用一个变量 size 表示栈的大小，当遇到左括号时就将其加一，遇到右括号时就将其减一，从而表示栈中元素的变化。这一过程中 size 的最大值即为 ss 的嵌套深度。

#### 代码

题目很长，但其实都是纸老虎

```go
func maxDepth(s string) int {
	res, size := 0, 0
	for _, v := range s {
		if v == '(' {
			size++
			if size > res {
				res = size
			}
		} else if v == ')' {
			size--
		}
	}
	return res
}
```

