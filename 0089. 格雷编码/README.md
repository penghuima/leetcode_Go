#### [89. 格雷编码](https://leetcode-cn.com/problems/gray-code/)

> 难度中等

**n 位格雷码序列** 是一个由 `2n` 个整数组成的序列，其中：

- 每个整数都在范围 `[0, 2n - 1]` 内（含 `0` 和 `2n - 1`）
- 第一个整数是 `0`
- 一个整数在序列中出现 **不超过一次**
- 每对 **相邻** 整数的二进制表示 **恰好一位不同** ，且
- **第一个** 和 **最后一个** 整数的二进制表示 **恰好一位不同**

给你一个整数 `n` ，返回任一有效的 **n 位格雷码序列** 。

**示例 1：**

```
输入：n = 2
输出：[0,1,3,2]
解释：
[0,1,3,2] 的二进制表示是 [00,01,11,10] 。
- 00 和 01 有一位不同
- 01 和 11 有一位不同
- 11 和 10 有一位不同
- 10 和 00 有一位不同
[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
- 00 和 10 有一位不同
- 10 和 11 有一位不同
- 11 和 01 有一位不同
- 01 和 00 有一位不同
```

**示例 2：**

```
输入：n = 1
输出：[0,1]
```

**提示：**

- `1 <= n <= 16`

#### 解题思路

> 不需要有格雷码的任何知识

题目可以转换为一共 2^n^ 个位置，依次向里面填入 [ 0,2^n^ -1]，使其满足格雷编码

这很明显我们可以使用回溯算法框架来 AC ，但却不容易写出来

**难点：**

- 如何构建选择列表，或者每次回溯从哪些选择列表中选择
- 位操作不熟练，不知道如何做到每次1位不同
- 子递归何时结束
- 如何在找到一个可行解后就立即结束递归，不再后续找其它可行解

**解答：**

1. 格雷编码每次都是从状态0开始，我们可以将其看成是 n 位全部 0 的二进制。 比如 n 是 3， 就看成是 000 接下来，我们对初始化的 000 执行一次位变换操作。可以变换为  001，010，100 。这就是我们的选择列表，每次从构建好的选择列表里做选择，另外需要used 哈希来防止重复选择一个数
2. 每次1位不同，我们可以使用异或来完成上面的转换， `for i:= 0;i<n;i++ {1<<i ^ 0}`     循环执行  `001 ^ 000 、 010 ^ 000、100 ^ 000`
3. 当我们 path切片中的元素个数等于  2^n^ 时，就可以结束子递归了
4. 在满足条件的同时，返回 true ，一层层向上返回 true 来结束递归

#### 代码

> 熟练一下位数的操作，以及异或操作 ^
>
> copy()切片操作是将源切片的值复制到目的切片的对应下标处，如果源切片的长度<目的切片 ，就无法复制目的切片的全部值了

```go
package leetcode

func grayCode(n int) []int {
	res := make([]int, 1<<n)
	var path []int
	used := make(map[int]bool, n)
	var backTrack func() bool
	//格雷码以0开始
	used[0] = true
	path = append(path, 0)
	backTrack = func() bool {
		//如果结果切片的长度达到 2的n次方
		if len(path) == 1<<n {
			copy(res, path)
			return true //找到正确解不再递归
		}
		for i := 0; i < n; i++ {
			//1<<i 等于2的i次方
			temp := 1<<i ^ path[len(path)-1]
			if used[temp] {
				continue
			}
			used[temp] = true
			path = append(path, temp)
			flag := backTrack()
			if flag {
				//一层层向上返回 true
				return true
			} else {
				used[temp] = false
				path = path[:len(path)-1]
			}
		}
		return false
	}
	backTrack()
	return res
}
```

