#### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

> 难度中等

给你一个大小为 `m x n` 的二进制矩阵 `grid` 。

**岛屿** 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在 **水平或者竖直的四个方向上** 相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。

岛屿的面积是岛上值为 `1` 的单元格的数目。

计算并返回 `grid` 中最大的岛屿面积。如果没有岛屿，则返回面积为 `0` 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)

```
输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
输出：6
解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。
```

**示例 2：**

```
输入：grid = [[0,0,0,0,0,0,0,0]]
输出：0
```

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 50`
- `grid[i][j]` 为 `0` 或 `1`

#### 解题思路

这都是一系列岛屿问题，只不过我们在统计岛屿数量的同时还应该记录每个岛屿的面积，即给dfs一个返回值，用来记录岛屿面积。

别看递归只加一个返回参数，就有的人弄不明白逻辑怎么写了。在写递归的时候，我们一定要知道该递归函数是干什么的，返回值的意义是什么。我们当前写的逻辑是**本层逻辑，即该层之后的所有层都处理完毕之后，将结果返回给该层之后，逻辑是什么样的**。在本题中，我们拿到四个方向的统计值之后，肯定在本层逻辑将这四个方向的值加起来，然后再加1（该位置，即从这个位置向四处深度遍历的）。

#### 代码

```go
//1土地 0 水
func maxAreaOfIsland(grid [][]int) int {
	res := 0
	m, n := len(grid), len(grid[0])
	visited := make([][]bool, m)
	for i := range visited {
		visited[i] = make([]bool, n)
	}
	var dfs func(i, j int) int
	dfs = func(i, j int) (area int) {
		//递归出口  越界 或者遇到海水
		if i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0 {
			return 0
		}
		//递归出口  已经遍历过(i,j)
		if visited[i][j] {
			return 0
		}
		//遍历位置(i,j)
		visited[i][j] = true
		//本层逻辑：拿到所有需要的底层数据后，进行逻辑处理，返回给上一层
		return dfs(i-1, j) + dfs(i+1, j) + dfs(i, j-1) + dfs(i, j+1) + 1
	}
	//遍历二维数组
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			//满足条件
			if grid[i][j] == 1 && visited[i][j] == false {
				res = max(res, dfs(i, j))
			}
		}
	}
	return res
}
func max(a, b int) int {
	if a > b {
		return a
	} else {
		return b
	}
}
```

